# モジュール
* cpp20[meta cpp]

## 概要
C++20では、インクルードに代わる新たな仕組みとしてモジュールが導入された。

C++20では、プリプロセッサを用いずにプログラムを分割することができる：

```cpp
// a.cpp
export module a; // aモジュールのインターフェース

void foo(){}
export void bar();
```
```cpp
// a_impl.cpp
module a;

void bar(){ foo(); } // OK、fooはエクスポートされていないが、同じモジュールの中では見える
```
```cpp
// main.cpp
import a; // aモジュールをインポート

int main()
{
    foo(); // エラー、fooはエクスポートされていないので見えない
    bar(); // OK、barはエクスポートされているので見える
}
```

さらに、インクルードから移行する過渡期において便利な機能として、グローバルモジュールフラグメント、ヘッダーユニットが用意された。

## 仕様

### モジュール宣言

モジュール宣言の構文は以下のようになる：

```
export(opt) module モジュール名 モジュールパーティション(opt) 属性(opt);
```

- モジュール宣言は翻訳単位あたり1回だけ記述できる。原則として翻訳単位の先頭に記述する。
- モジュール宣言を含む翻訳単位をモジュールユニットという。
    - 特に、`export`がある場合をモジュールインターフェースユニットという。あるモジュールについて、モジュールインターフェースユニットがただ1つ存在しなければならない。
- モジュール名は、識別子または識別子をドットで繋いだもの(例えば、`foo`や`std.core`)である。
- モジュールパーティションは、コロン(`:`)の後にモジュール名が続くものである。モジュールを分割する場合に用いる。
    - `export` がある場合、その翻訳単位をモジュールインターフェースパーティション、ない場合はモジュール実装パーティションという。

```cpp
export module foo; // fooのモジュールインターフェースユニット
```
```cpp
module foo; // fooのモジュールユニット
```
```cpp
module foo.bar; // foo.barのモジュールユニット
```
```cpp
export module bar [[deprecated]]; // 属性
```

### エクスポート

モジュールインターフェースユニットの中では、宣言に`export`キーワードを付加することでその対象をエクスポートできる。
モジュールをインポートすると、エクスポートした宣言が見える(名前解決の候補に挙がる)ようになる。

```cpp
export int x; // 変数のエクスポート
export class x{ /*...*/ }; // クラスのエクスポート
export namespace x { /*...*/ } // 名前空間のエクスポート
```

また、波カッコに`export`をつけることで、その中の宣言をまとめてエクスポートできる。この波カッコはスコープを作らない。

```cpp
export {
    void f();
}
```

エクスポートした宣言は外部リンケージになる。逆に、明示的に内部リンケージである宣言をエクスポートすると、エラーとなる。

### インポート

モジュールのインポートは次のようになる：

```cpp
import lib; // libのインポート
```

モジュールをインポートすると、そのモジュールがエクスポートしている宣言が見える(名前解決の候補に挙がる)ようになる。

- エクスポートしていない宣言は見えない。
- マクロは取り込まれない。

インポート宣言はエクスポートできる。これを再エクスポートという。

```cpp
export import lib; // libの再エクスポート： libがエクスポートしている宣言をエクスポートしたことになる。
```

### モジュールパーティション

モジュールをいくつかのモジュールパーティションへ分割することができる。

モジュールパーティションを宣言する場合のモジュール宣言の構文は以下のようになる：

```
export(opt) module モジュール名:モジュールパーティション名 属性(opt);
```

- モジュールパーティション名の書式は、モジュール名と同じである。
- `export` がある場合、その翻訳単位をモジュールインターフェースパーティション、ない場合はモジュール実装パーティションという。
    - モジュール実装パーティションでは何もエクスポートしてはいけない

```cpp
export module lib:part; // libモジュールのモジュールインターフェースパーティションpart
```
```cpp
module lib:internal; // libモジュールのモジュール実装パーティションinternal
```

モジュールパーティションは基本的に別のモジュールと考えてよいが、以下の点で異なる：

- 名前解決において、主となるモジュールと同じモジュールのように振る舞う
    - モジュールパーティションをインポートしたとき、`export` の有無に関係なくすべての宣言が見えるようになる
- インポートするとき、モジュールパーティション名だけを書き、主となるモジュールの名前を書かない
    - 主となるモジュールが異なる場合はインポートできない

別モジュールのパーティションはインポートできないので、モジュールの利用者にパーティションの存在を意識させてはいけない。
モジュールパーティション内の宣言を別のモジュールへ公開するには、主となるモジュールから再エクスポートをする。

```cpp
export module foo;
import :part;    // foo:partをインポート
import bar:part; // エラー: 別のモジュールの一部をインポートするのは不可
import foo:part; // エラー: 同じモジュールでも、:の前を書くのは不可
```

### グローバルモジュールフラグメント

モジュールインターフェースユニットでヘッダーファイルをインクルードしたい場合、グローバルモジュールフラグメントを使うことができる。

```cpp
module; // グローバルモジュールフラグメントの宣言
#include <iostream>
export module foo;
// 
```

### ヘッダーユニット

ヘッダーユニットは、ヘッダーファイルのインクルードとモジュールの中間的な機能である。

```cpp
import <iostream>; // iostreamをヘッダーユニットとしてインポート
```

ヘッダーファイルをヘッダーユニットとしてインポートすることの効果は、インクルードする場合とほとんど同じである。

- ヘッダーファイル中の宣言が見えるようになる
- マクロが引き継がれる

ただし、これはプリプロセッサではない。
ヘッダーファイル中に`import`や`export`が書かれていても、その影響はない。
「ヘッダーファイル中の宣言をすべてエクスポートしているようなモジュールを仮想的にインポートする」と考えるとわかりやすい。

ヘッダーユニットは再エクスポートできる。

```cpp
export import "lib.h";
```

ヘッダーユニットは、ヘッダーファイルで提供されているライブラリをモジュールでラップするのに使うことができる。

```cpp
// lib.h中の宣言をすべてエクスポートするモジュールlib
export module lib;
export import "lib.h";
```

## この機能が必要になった背景・経緯
プリプロセッサによるインクルードは、ヘッダーファイルの内容をその場に展開する。これによってコンパイル時間が長くなる問題があった。

- インクルードが再帰的に展開され、ソースが長くなる（Hello worldだけでも数万行に達する）
- さらに、展開が翻訳単位ごとに行われるので、全体で見ると同じヘッダーファイルが何度も解析される

また、プリプロセッサの状態により、インクルードの結果が変わってしまう。インクルードの順番によってエラーが起きることがあった。

モジュールは、以上のような問題のないプログラム分割の仕組みとして導入された。

## 参照
- [P1103R3 Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf)
