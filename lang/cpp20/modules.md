# モジュール
* cpp20[meta cpp]

## 概要
C++20では、インクルードに代わる新たな仕組みとしてモジュールが導入された。

C++20では、プリプロセッサを用いずにプログラムを分割することができる：

```cpp
// a.cpp
export module a; // aモジュールのインターフェース

void foo(){}
export void bar(); // 関数barをエクスポート
```
```cpp
// a_impl.cpp
module a;

void bar(){ foo(); } // OK、fooはエクスポートされていないが、同じモジュールの中では見える
```
```cpp
// main.cpp
import a; // aモジュールをインポート

int main()
{
    foo(); // エラー、fooはエクスポートされていないので見えない
    bar(); // OK、barはエクスポートされているので見える
}
```

## 仕様

### モジュール宣言

モジュール宣言の構文は以下のようになる：

```
export(opt) module モジュール名 属性(opt);
```

- モジュール宣言は翻訳単位あたり1回だけ記述でき、翻訳単位の先頭に記述する。
- モジュール宣言を含む翻訳単位をモジュールユニットという。
    - `export`がある場合をモジュールインターフェースユニット、ない場合をモジュール実装ユニットと呼ぶ。
    - あるモジュールについて、モジュールインターフェースユニットがただ1つ存在しなければならない。モジュールの実装は好きなだけ存在できる。
- モジュール名は、識別子または識別子をドットで繋いだもの(例えば、`foo`や`std.core`)である。

```cpp
export module foo; // fooのモジュールインターフェースユニット
```
```cpp
module foo; // fooのモジュールユニット
```
```cpp
module foo.bar; // foo.barのモジュールユニット
```
```cpp
export module bar [[deprecated]]; // 属性
```

#### グローバルモジュール

C++20では、名前のあるモジュールに属していない宣言はグローバルモジュールに属している。

グローバルモジュールの性質は以下の通り。

* 名前を持たず、インポートすることはできない。
* 宣言をエクスポートすることはできない。
* モジュールインターフェースユニットを持つことはできない。

### エクスポート

モジュールインターフェースユニットの中では、宣言に`export`キーワードを付加することでその対象をエクスポートできる。
モジュールをインポートすると、エクスポートした宣言が見える(名前解決の候補に挙がる)ようになる。

モジュール実装ユニットでは、エクスポートできない。

```cpp
export int x; // 変数のエクスポート
export class x{ /*...*/ }; // クラスのエクスポート
export namespace x { /*...*/ } // 名前空間のエクスポート
export template<class T> foobar(); // 関数テンプレートのエクスポート
```

また、波カッコに`export`をつけることで、その中の宣言をまとめてエクスポートできる。この波カッコはスコープを作らない。

```cpp
export {
    void f();
}
```

* `export`を付けた宣言が新たな名前を宣言していない場合は、エラーとなる。
* 内部リンケージを持つ名前をエクスポートすると、エラーとなる。

#### モジュールリンケージ

C++20では、新たにモジュールリンケージが追加された。

* 名前のあるモジュールに属していてエクスポートしていない名前は、モジュールリンケージを持つ。
    * エクスポートしている名前は外部リンケージを持つ。
* モジュールリンケージを持つ名前は、同一モジュール内で参照できる。

### インポート

モジュールのインポート宣言は次のようになる：

```cpp
import lib; // libのインポート
```

モジュールをインポートすると、そのモジュールがエクスポートしている宣言が見える(名前解決の候補に挙がる)ようになる。

- エクスポートしていない宣言は見えない。
- マクロは取り込まれない。

インポート宣言もエクスポートできる。これを再エクスポートという。

```cpp
export import lib; // libの再エクスポート
```

再エクスポートすると、インポートで見えるようになった宣言をそのままエクスポートしたことになる。

### モジュールパーティション

モジュールは分割することができる。分割したモジュールをモジュールパーティションという。

モジュールパーティションを宣言する構文は以下のようになる：

```
export(opt) module モジュール名:モジュールパーティション名 属性(opt);
```

- モジュールパーティション名の書式は、モジュール名と同じである。
- `export` がある場合をモジュールインターフェースパーティション、ない場合をモジュール実装パーティションという。

```cpp
export module lib:part; // libモジュールのモジュールインターフェースパーティションpart
```
```cpp
module lib:internal; // libモジュールのモジュール実装パーティションinternal
```

モジュールパーティションは基本的に別のモジュールと考えてよいが、以下の点で異なる：

- 主となるモジュールが異なる場合はインポートできない。
    - 外部へ公開するには、モジュールインターフェースから再エクスポートする。
    - モジュールの利用者にパーティションの存在を意識させてはいけない。
- インポート宣言にはモジュールパーティション名だけを書く。
- インポートするとエクスポートしていない宣言も見えるようになる。
    - ただし、再エクスポートはできない。

```cpp
export module foo;
import :part;          // foo:partをインポート
export import :part2;  // foo:part2を再エクスポート
import bar:part3;      // エラー: 別のモジュールからはインポート不可
import foo:part4;      // エラー: モジュール名を書くのは不可
```

### ODRの緩和

C++20では、複数の定義が同時に見えるようにならない限りODR違反とならない。

```cpp
// a.cpp
export module A;

export void foo(){}
```
```cpp
// b.cpp
export module B;

export void foo(){}
```
```cpp
import A;

int main()
{
    foo();
}
```

このプログラムでは、関数`foo`をモジュールA,Bで2回定義しているが、モジュールA,Bを同時にインポートしていないのでODR違反とならない。

## 後方互換性のための機能

### グローバルモジュールフラグメント

モジュール宣言の前にグローバルモジュールの実装を書くことができる。これをグローバルモジュールフラグメントという。

グローバルモジュールフラグメントにはプリプロセッサディレクティブのみ記述できる。
翻訳フェーズ4以前の段階でプリプロセッサディレクティブ以外の記述がある場合は、エラーとなる。

この機能は、モジュールのインターフェースへ影響を与えずにインクルードをするために用意された。

```cpp
module;             // グローバルモジュールフラグメントの宣言

#include <iostream> // <iostream>中の宣言はモジュールfooに含まれない。

export module foo;

#include "lib.h"    // "lib.h"中の宣言がモジュールfooに含まれてしまう(モジュールリンケージを持ってしまう)。

void f() {
    std::cout << "foo" << std::endl;
}
// 
```

### ヘッダーユニット

ヘッダーユニットは、ヘッダーファイルをモジュールとしてインポートする機能である。
ヘッダーファイル内の宣言が見えるようになり、通常のモジュールとは異なりマクロも引き継がれる。

```cpp
import <iostream>; // iostreamをヘッダーユニットとしてインポート
```

ヘッダーユニットは再エクスポートできるため、ライブラリをモジュールでラップするのに使うことができる。

```cpp
// lib.h

inline int f(){ return NUM; }

#define NUM 1000

```

```cpp
// lib_mod.cpp
// lib.h中の宣言をすべてエクスポートするモジュールlib
export module lib;
export import "lib.h";

```

```cpp
// main.cpp
import lib;

int main() {
    1 + f(); // OK
    1 + NUM; // エラー: マクロは再エクスポートしても引き継がれない
}
```

ヘッダーユニットをインポートすると以下のことが起こる。

* ヘッダーファイルをプリプロセスし、その時定義されていたマクロをインポート宣言の直後で再定義する。
* ヘッダーファイルをフェーズ7までコンパイルし、その翻訳単位(ヘッダーユニット)をインポートする。
    * 内部リンケージを持たない名前は暗黙的にエクスポートされる。
    * ヘッダーユニットはモジュール宣言を持てない。ヘッダーユニット内の宣言はグローバルモジュールに属する。

C++20では、`#include` プリプロセッサディレクティブがヘッダーユニットのインポートに置き換えられる場合がある。

## ビルド

プログラムのビルドは規格の範囲外なので、ここでは一般論を述べる。

モジュールをコンパイルすると、何らかの中間表現(コンパイル済みモジュール)が保存される。

- テンプレートはテンプレートのまま（実体化することなく）エクスポートできるので、中間表現は機械語ではなく、いわゆるプリコンパイルドヘッダーと似たようなものにならざるを得ない。
- モジュールAをインポートするプログラムをコンパイルするには、モジュールAのコンパイル済みモジュールが存在しなければならない。
- モジュールAをインポートするプログラムをリンクするには、モジュールAに関するモジュールユニットから生成されるオブジェクトファイル、ライブラリなどを別途リンクしなければならない。

## この機能が必要になった背景・経緯

プリプロセッサによるインクルードは、ヘッダーファイルの内容をその場に展開する。
これには次のような問題が指摘されてきた。

1. コンパイル時間が長くなる
    - ヘッダーファイルの内容が再帰的に展開され、プログラムが長くなる（Hello worldだけでも数万行に達する）
    - さらに、展開が翻訳単位ごとに行われるので、全体で見ると同じヘッダーファイルが何度も解析される
2. プリプロセッサの状態により、インクルードの結果が変わってしまう
    - インクルードの順番によってエラーが起きることがあった。
3. ヘッダーファイル内の記述の影響を受けすぎる
    - 影響が大きいため、ヘッダーファイル内に書くことがためらわれる記述があった。
    - `using namespace`やマクロ(例えばWindowsにおける`max`)など。

モジュールは、以上のような問題のないプログラム分割の仕組みとして導入された。

## 参照
- [P1103R3 Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf)
