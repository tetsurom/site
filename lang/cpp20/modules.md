# モジュール
* cpp20[meta cpp]

## 概要
C++20では、インクルードに代わる新たな仕組みとしてモジュールが導入された。

C++20では、プリプロセッサを用いずにプログラムを分割することができる：

```cpp
// a.cpp
export module a; // aモジュールのインターフェース

void foo(){}
export void bar(); // 関数barをエクスポート
export template<class T> foobar(); // 関数テンプレートをエクスポート
```
```cpp
// a_impl.cpp
module a;

void bar(){ foo(); } // OK、fooはエクスポートされていないが、同じモジュールの中では見える
```
```cpp
// main.cpp
import a; // aモジュールをインポート

int main()
{
    foo(); // エラー、fooはエクスポートされていないので見えない
    bar(); // OK、barはエクスポートされているので見える
}
```

## 仕様

### モジュール宣言

モジュール宣言の構文は以下のようになる：

```
export(opt) module モジュール名 属性(opt);
```

- モジュール宣言は翻訳単位あたり1回だけ記述でき、翻訳単位の先頭に記述する。
- モジュール宣言を含む翻訳単位をモジュールユニットという。
    - 特に、`export`がある場合をモジュールインターフェースユニットという。`export`がない場合は特別な名前は無いが、ここではモジュールの実装と呼ぶ。
    - あるモジュールについて、モジュールインターフェースユニットがただ1つ存在しなければならない。モジュールの実装は好きなだけ存在できる。
- モジュール名は、識別子または識別子をドットで繋いだもの(例えば、`foo`や`std.core`)である。

```cpp
export module foo; // fooのモジュールインターフェースユニット
```
```cpp
module foo; // fooのモジュールユニット
```
```cpp
module foo.bar; // foo.barのモジュールユニット
```
```cpp
export module bar [[deprecated]]; // 属性
```

### エクスポート

モジュールインターフェースユニットの中では、宣言に`export`キーワードを付加することでその対象をエクスポートできる。
モジュールをインポートすると、エクスポートした宣言が見える(名前解決の候補に挙がる)ようになる。

モジュールの実装では、エクスポートできない。

```cpp
export int x; // 変数のエクスポート
export class x{ /*...*/ }; // クラスのエクスポート
export namespace x { /*...*/ } // 名前空間のエクスポート
```

また、波カッコに`export`をつけることで、その中の宣言をまとめてエクスポートできる。この波カッコはスコープを作らない。

```cpp
export {
    void f();
}
```

内部リンケージを持つ宣言をエクスポートすると、エラーとなる。


### インポート

モジュールのインポートは次のようになる：

```cpp
import lib; // libのインポート
```

モジュールをインポートすると、そのモジュールがエクスポートしている宣言が見える(名前解決の候補に挙がる)ようになる。

- エクスポートしていない宣言は見えない。
- マクロは取り込まれない。

インポート宣言もエクスポートできる。これを再エクスポートという。

```cpp
export import lib; // libの再エクスポート
```

再エクスポートすると、インポートで見えるようになった宣言をそのままエクスポートしたことになる。

### モジュールパーティション

モジュールは分割することができる。分割したモジュールをモジュールパーティションという。

モジュールパーティションを宣言する構文は以下のようになる：

```
export(opt) module モジュール名:モジュールパーティション名 属性(opt);
```

- モジュールパーティション名の書式は、モジュール名と同じである。
- `export` がある場合をモジュールインターフェースパーティション、ない場合をモジュール実装パーティションという。

```cpp
export module lib:part; // libモジュールのモジュールインターフェースパーティションpart
```
```cpp
module lib:internal; // libモジュールのモジュール実装パーティションinternal
```

モジュールパーティションは基本的に別のモジュールと考えてよいが、以下の点で異なる：

- 主となるモジュールが異なる場合はインポートできない
    - 外部へ公開するには、モジュールインターフェースから再エクスポートする
    - モジュールの利用者にパーティションの存在を意識させてはいけない
- インポートするとき、モジュールパーティション名だけを書く
- インポートするとエクスポートしていない宣言も見えるようになる
    - ただし、再エクスポートはできない

```cpp
export module foo;
import :part;          // foo:partをインポート
export import :part2;  // foo:part2を再エクスポート
import bar:part3;      // エラー: 別のモジュールからはインポート不可
import foo:part4;      // エラー: モジュール名を書くのは不可
```

### ODRの緩和

モジュール内の定義については、複数の定義が同時に見えるようにならない限りは、ODR違反とならない。

```cpp
// a.cpp
export module A;

void foo(){}
```
```cpp
// b.cpp
export module B;

void foo(){}
```
```cpp
import A;

int main()
{
    foo();
}
```

このプログラムでは、関数`foo`をモジュールA,Bで2回定義しているが、モジュールA,Bを同時にインポートしていないのでODR違反とならない。

## 後方互換性のための機能

### グローバルモジュールフラグメント

モジュール宣言の前に、名前のないモジュールの実装を書くことができる。これをグローバルモジュールフラグメントという。

グローバルモジュールフラグメントに書いた宣言はそのモジュールユニット内で参照できるが、モジュールには含まれない。
これを利用して、モジュールインターフェースへの影響を排除しながらインクルードすることができる。

```cpp
module;             // グローバルモジュールフラグメントの宣言

#include <iostream> // <iostream>中の宣言はモジュールfooに含まれない。

export module foo;

#include "lib.h"    // "lib.h"中の宣言がモジュールfooに含まれてしまう。

void f() {
    std::cout << "foo" << std::endl;
}
// 
```

### ヘッダーユニット

ヘッダーユニットは、ヘッダーファイルのインクルードとモジュールのインポートの中間的な機能である。

```cpp
import <iostream>; // iostreamをヘッダーユニットとしてインポート
```

ヘッダーファイルをヘッダーユニットとしてインポートすると、ヘッダーファイル中の宣言が見えるようになるだけでなく、マクロも引き継がれる。
ヘッダーユニットは再エクスポートできるため、ライブラリをモジュールでラップするのに使うことができる。

```cpp
// lib.h

inline int f(){ return NUM; }

#define NUM 1000

```

```cpp
// lib_mod.cpp
// lib.h中の宣言をすべてエクスポートするモジュールlib
export module lib;
export import "lib.h";

```

```cpp
// main.cpp
import lib;

int main() {
    1 + f(); // OK
    1 + NUM; // エラー: マクロは再エクスポートしても引き継がれない
}
```

## ビルド

プログラムのビルドは規格の範囲外なので、ここでは一般論を述べる。

モジュールをコンパイルすると、何らかの中間表現(コンパイル済みモジュール)が保存される。

- テンプレートはテンプレートのまま（実体化することなく）エクスポートできるので、中間表現は機械語ではなく、いわゆるプリコンパイルドヘッダーと似たようなものにならざるを得ない。
- モジュールAをインポートするプログラムをコンパイルするには、モジュールAのコンパイル済みモジュールが存在しなければならない。
- モジュールAをインポートするプログラムをリンクするには、モジュールAに関するモジュールユニットから生成されるオブジェクトファイル、ライブラリなどを別途リンクしなければならない。

## この機能が必要になった背景・経緯

プリプロセッサによるインクルードは次のような問題が指摘されている。

1. コンパイル時間が長くなる
    - ヘッダーファイルの内容が再帰的に展開され、プログラムが長くなる（Hello worldだけでも数万行に達する）
    - さらに、展開が翻訳単位ごとに行われるので、全体で見ると同じヘッダーファイルが何度も解析される
2. プリプロセッサの状態により、インクルードの結果が変わってしまう
    - インクルードの順番によってエラーが起きることがあった。
3. ヘッダーファイル内の記述の影響を受けすぎる
    - 影響が大きいため、ヘッダーファイル内に書くことがためらわれる記述があった。
    - `using namespace`やマクロ(例えばWindowsにおける`max`)など。

モジュールは、以上のような問題のないプログラム分割の仕組みとして導入された。

## 参照
- [P1103R3 Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf)
